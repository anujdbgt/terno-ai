import terno.models as models
from django.views.decorators.cache import cache_page
from openai import OpenAI
from sqlshield.shield import Session
from sqlshield.models import MDatabase
import sqlalchemy
from django.conf import settings


def get_all_group_tables(datasource, roles):
    table_object = models.PrivateTableSelector.objects.filter(
        data_source=datasource).first()
    global_tables = models.Table.objects.filter(
        data_source=datasource)
    if table_object:
        global_tables_ids = table_object.tables.all().values_list('id', flat=True)
        global_tables = global_tables.exclude(id__in=global_tables_ids)

    group_tables_object = models.GroupTableSelector.objects.filter(
        group__in=roles,
        tables__data_source=datasource).first()
    if group_tables_object:
        group_tables = group_tables_object.tables.all()
        all_group_tables = global_tables.union(group_tables)
    else:
        all_group_tables = global_tables
    return all_group_tables


# @cache_page(24*3600)
def get_admin_config_object(datasource, roles):
    """
    Tables and columns accessible for user
    """
    all_group_tables = get_all_group_tables(datasource, roles)
    all_group_tables_ids = list(all_group_tables.values_list('id', flat=True))
    table_columns = models.TableColumn.objects.filter(table_id__in=all_group_tables_ids)
    group_columns_object = models.GroupColumnSelector.objects.filter(
        group__in=roles,
        columns__in=table_columns).first()
    if group_columns_object:
        group_columns = group_columns_object.columns.all()
    else:
        group_columns = table_columns
    print('final tables', all_group_tables)
    print('final columns', group_columns)
    return all_group_tables, group_columns


def llm_response(question, schema_generated):
    client = OpenAI(api_key=settings.OPENAI_API_KEY)
    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": "You are an SQL Analyst. Your role is to generate the SQL given a question. Only generate SQL without markdown and nothing else."},
            {"role": "user", "content": question},
            {"role": "assistant", "content": "The database schema is as follows: " + schema_generated},
        ]
    )
    aSql = response.choices[0].message.content
    print('SQL Generated by LLM: ', aSql)
    return aSql


# @cache_page(24*3600)
def generate_mdb(datasource):
    engine = sqlalchemy.create_engine(datasource.connection_str)
    inspector = sqlalchemy.inspect(engine)
    mDb = MDatabase.from_inspector(inspector)
    return mDb


def generate_native_sql(mDb, aSql):
    d = {'company': '\'Telus\''}
    sess = Session(mDb, d)
    try:
        gSQL = sess.generateNativeSQL(aSql)
        print("Native SQL: ", gSQL)
        status = 'success'
        return status, gSQL
    except Exception as e:
        status = 'failed'
        error = e.args[0]
        return status, error


def execute_native_sql(datasource, gSQL):
    engine = sqlalchemy.create_engine(datasource.connection_str)
    with engine.connect() as con:
        try:
            rs = con.execute(sqlalchemy.text(gSQL))
            status = 'success'
        except Exception as e:
            status = 'failed'
            error = e.args[0]
            return status, error
        table_data = {}
        table_data['columns'] = list(rs.keys())
        table_data['data'] = []
        for row in rs:
            data = {}
            for i, column in enumerate(table_data['columns']):
                data[column] = row[i]
            table_data['data'].append(data)
        return status, table_data
